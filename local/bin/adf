#!/bin/sh
#
# local/bin/adf
# Copyright 2023 Keith Maxwell
# SPDX-License-Identifier: MPL-2.0
#

ADF_DPI="${ADF_DPI:-200}"
ADF_VIEWER="${ADF_VIEWER:-google-chrome}"

export SANE_CONFIG_DIR="$HOME/.config/adf"

die() {
	printf '%s\n' "$1"
	exit 1
}
files() { ls adf.????.pbm >/dev/null 2>&1 ; }

_acquire() {
	scanimage \
		"--resolution=$ADF_DPI" \
		-x210 \
		-y297 \
		"$@"
}
acquire() {
	if [ "$1" = '--no-clean' ]; then shift
	elif files ; then die "Run '${0##*/} clean' first."
	fi

	if ! command -v scanimage >/dev/null 2>&1 ; then
		die "scanimage not found; try installing sane-frontends"
	fi

	# scanadf causes a segmentation fault; scanimage doesn't
	devices="$(scanimage --list-devices 2>/dev/null)"
	case "$devices" in
		*LiDE25*)
			_acquire \
				--mode=Lineart \
				--output-file=adf.%04d.pbm \
				"$@"
			;;
		*brother5*)
			_acquire \
				"--mode=Black & White" \
				"--source=Automatic Document Feeder(center aligned,Duplex)" \
				--batch=adf.%04d.pbm \
				"$@"
			;;
		*)
			die "Recognised scanner not present."
			;;
	esac
}
encode() {
	[ "$#" -gt 0 ] || die "Missing output filename"
	output="$1"
	shift

	case "$output" in
		/*) ;;
		*) output="$PWD/$output" ;;
	esac
	directory="$(dirname "$output")"
	if [ ! -d "$directory" ] ; then
		die "$directory does not exist."
	fi

	if ! jbig2 --version 2>/dev/null ; then
		die "jbig2 --version failed."
	fi

	if ! command -v jbig2topdf.py > /dev/null 2>&1 ; then
		die "jbig2topdf.py not found."
	fi

	if ! files ; then
		die "No input files found, exiting.\nRun '${0##*/} acquire' first."
	fi

	jbig2 -b jbig2basename$$ --dpi "$ADF_DPI" --pdf --symbol-mode "$@" adf.????.pbm || return 1
	jbig2topdf.py jbig2basename$$ > "$output" || return 1
	rm -f jbig2basename$$.sym jbig2basename$$.???? || return 1

	if command -v "$ADF_VIEWER" >/dev/null 2>&1 ; then
		"$ADF_VIEWER" "$output" >/dev/null 2>&1 &
	fi
	printf '%s\n' "$output"
}
clean() {
	rm -f adf.????.pbm
}
prepare() {
	[ "$#" -gt 0 ] || die "Missing output filename"
	output="$1"
	shift

	acquire "$@" && encode "$output"
}
full() {
	prepare "$@" && clean
}

command="${1}"
shift
case "${command}" in
	a*) acquire "$@" ;;
	c*) clean "$@" ;;
	e*) encode "$@" ;;
	f*) full "$@" ;;
	p*) prepare "$@" ;;
	*) die "Usage: ${0##*/} acquire|clean|encode|full|prepare" ;;
esac

# vim: set noexpandtab nolist softtabstop=0 tabstop=4 shiftwidth=4 :
